<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Centre d'Effets Optiques</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            background-color: #000;
            color: #fff;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: #000; /* Fond noir pour le mode plein écran */
        }

        .canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #000;
        }

        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        #fullscreen-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            background: rgba(50, 50, 50, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            padding: 5px;
        }
        #fullscreen-btn svg {
            width: 100%;
            height: 100%;
            fill: white;
        }

        .controls-panel {
            flex-shrink: 0;
            padding: 15px;
            background-color: rgba(10, 10, 10, 0.8);
            border-top: 1px solid #333;
            box-sizing: border-box;
        }

        .effect-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
            gap: 10px;
        }

        .effect-selector button {
            padding: 8px 15px;
            font-size: 14px;
            color: white;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .effect-selector button.active {
            background-color: #ff69b4;
            border-color: #ff69b4;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            white-space: nowrap;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .control-group.single-button {
             grid-column: 1 / -1;
             text-align: center;
        }
         .control-group.single-button button {
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            background-color: #555;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .control-group span {
            float: right;
            font-family: monospace;
            color: #ff69b4;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>

    <div class="main-container">
        <div class="canvas-container">
            <!-- Le canvas sera créé et inséré ici par le script -->
            <button id="fullscreen-btn" title="Plein écran">
                <svg id="icon-enter-fs" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg>
                <svg id="icon-exit-fs" viewBox="0 0 24 24" class="hidden"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></svg>
            </button>
        </div>
        <div class="controls-panel">
            <div class="effect-selector">
                <button id="btn-spiral" class="active">Spirale</button>
                <button id="btn-tunnel">Tunnel</button>
                <button id="btn-kaleidoscope">Kaléidoscope</button>
                <button id="btn-gravwave">Onde Gravit.</button>
                <button id="btn-fractal">Fractale</button>
            </div>
            <div id="controls-container" class="controls-grid">
                <!-- Contrôles pour la Spirale -->
                <div class="control-group" data-effect="spiral">
                    <label>Branches <span id="spiral-arms-value">6</span></label>
                    <input type="range" id="spiral-arms" min="1" max="20" step="1" value="6">
                </div>
                <div class="control-group" data-effect="spiral">
                    <label>Vitesse <span id="spiral-speed-value">1.0</span></label>
                    <input type="range" id="spiral-speed" min="-5" max="5" step="0.1" value="1.0">
                </div>
                <div class="control-group" data-effect="spiral">
                    <label>Épaisseur <span id="spiral-thickness-value">4</span></label>
                    <input type="range" id="spiral-thickness" min="1" max="20" step="1" value="4">
                </div>
                <div class="control-group" data-effect="spiral">
                    <label>Vitesse Couleur <span id="spiral-color-speed-value">20</span></label>
                    <input type="range" id="spiral-color-speed" min="0" max="100" step="1" value="20">
                </div>
                
                <!-- Contrôles pour le Tunnel -->
                <div class="control-group hidden" data-effect="tunnel">
                    <label>Densité <span id="tunnel-density-value">200</span></label>
                    <input type="range" id="tunnel-density" min="50" max="500" step="10" value="200">
                </div>
                 <div class="control-group hidden" data-effect="tunnel">
                    <label>Vitesse <span id="tunnel-speed-value">5</span></label>
                    <input type="range" id="tunnel-speed" min="1" max="20" step="0.5" value="5">
                </div>

                <!-- Contrôles pour le Kaléidoscope -->
                <div class="control-group hidden" data-effect="kaleidoscope">
                    <label>Divisions <span id="k-slices-value">8</span></label>
                    <input type="range" id="k-slices" min="4" max="24" step="2" value="8">
                </div>
                <div class="control-group hidden" data-effect="kaleidoscope">
                    <label>Vitesse <span id="k-speed-value">0.5</span></label>
                    <input type="range" id="k-speed" min="0.1" max="2" step="0.1" value="0.5">
                </div>

                <!-- Contrôles pour l'Onde Gravitationnelle -->
                <div class="control-group hidden" data-effect="gravwave">
                    <label>Amplitude <span id="gw-amplitude-value">0.25</span></label>
                    <input type="range" id="gw-amplitude" min="0" max="1" step="0.01" value="0.25">
                </div>
                <div class="control-group hidden" data-effect="gravwave">
                    <label>Longueur d'onde <span id="gw-wavelength-value">150</span></label>
                    <input type="range" id="gw-wavelength" min="20" max="500" step="1" value="150">
                </div>

                <!-- Contrôles pour la Fractale -->
                <div class="control-group single-button hidden" data-effect="fractal">
                    <button id="fractal-reset">Réinitialiser le Zoom</button>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script id="fractal-worker" type="javascript/worker">
        function map(value, start1, stop1, start2, stop2) { return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1)); }
        function hslToRgb(h, s, l){ let r, g, b; if(s == 0){ r = g = b = l; }else{ const hue2rgb = (p, q, t) => { if(t < 0) t += 1; if(t > 1) t -= 1; if(t < 1/6) return p + (q - p) * 6 * t; if(t < 1/2) return q; if(t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p; }; const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3); } return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)]; }
        function drawMandelbrot(width, height, centerX, centerY, scale, maxIterations) { const imageData = new ImageData(width, height); const data = imageData.data; for (let x = 0; x < width; x++) { for (let y = 0; y < height; y++) { let a = map(x, 0, width, centerX - scale, centerX + scale); let b = map(y, 0, height, centerY - scale, centerY + scale); let ca = a; let cb = b; let n = 0; while (n < maxIterations) { const aa = a * a - b * b; const bb = 2 * a * b; a = aa + ca; b = bb + cb; if (a * a + b * b > 4) break; n++; } const index = (x + y * width) * 4; if (n === maxIterations) { data[index] = 0; data[index+1] = 0; data[index+2] = 0; data[index+3] = 255; } else { const hue = map(Math.sqrt(n / maxIterations), 0, 1, 0, 360); const [r, g, b] = hslToRgb(hue / 360, 0.9, 0.5); data[index] = r; data[index+1] = g; data[index+2] = b; data[index+3] = 255; } } } return imageData; }
        self.onmessage = function(e) { const { width, height, centerX, centerY, scale, maxIterations } = e.data; const imageData = drawMandelbrot(width, height, centerX, centerY, scale, maxIterations); self.postMessage(imageData); };
    </script>

    <script type="module">
        // --- Imports et Setup Global ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let canvas;
        const mainContainer = document.querySelector('.main-container');
        const canvasContainer = document.querySelector('.canvas-container');
        let ctx;

        let currentEffect = 'spiral';
        let time = 0;
        let animationFrameId;

        // --- États et Configurations des Effets ---
        let three, fractal, tunnelParticles = [];
        const config = {
            spiral: { arms: 6, rotationSpeed: 1.0, thickness: 4, colorSpeed: 20 },
            tunnel: { density: 200, speed: 5 },
            kaleidoscope: { slices: 8, speed: 0.5 },
            gravwave: { amplitude: 0.25, wavelength: 150.0, gridSize: 50, gridSpacing: 3 },
            fractal: { centerX: -0.5, centerY: 0, scale: 2, maxIterations: 100 }
        };

        // --- Gestion des UI ---
        const effectButtons = document.querySelectorAll('.effect-selector button');
        const allControls = document.querySelectorAll('.control-group');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const iconEnterFs = document.getElementById('icon-enter-fs');
        const iconExitFs = document.getElementById('icon-exit-fs');

        effectButtons.forEach(btn => btn.addEventListener('click', () => switchEffect(btn.id.replace('btn-', ''))));
        
        // --- Liaison des Contrôles ---
        function setupEventListeners() {
            document.getElementById('spiral-arms').addEventListener('input', e => { config.spiral.arms = parseInt(e.target.value); document.getElementById('spiral-arms-value').textContent = e.target.value; });
            document.getElementById('spiral-speed').addEventListener('input', e => { config.spiral.rotationSpeed = parseFloat(e.target.value); document.getElementById('spiral-speed-value').textContent = parseFloat(e.target.value).toFixed(1); });
            document.getElementById('spiral-thickness').addEventListener('input', e => { config.spiral.thickness = parseInt(e.target.value); document.getElementById('spiral-thickness-value').textContent = e.target.value; });
            document.getElementById('spiral-color-speed').addEventListener('input', e => { config.spiral.colorSpeed = parseInt(e.target.value); document.getElementById('spiral-color-speed-value').textContent = e.target.value; });
            document.getElementById('tunnel-density').addEventListener('input', e => { config.tunnel.density = parseInt(e.target.value); document.getElementById('tunnel-density-value').textContent = e.target.value; initTunnel(); });
            document.getElementById('tunnel-speed').addEventListener('input', e => { config.tunnel.speed = parseFloat(e.target.value); document.getElementById('tunnel-speed-value').textContent = e.target.value; });
            document.getElementById('k-slices').addEventListener('input', e => { config.kaleidoscope.slices = parseInt(e.target.value); document.getElementById('k-slices-value').textContent = e.target.value; });
            document.getElementById('k-speed').addEventListener('input', e => { config.kaleidoscope.speed = parseFloat(e.target.value); document.getElementById('k-speed-value').textContent = parseFloat(e.target.value).toFixed(1); });
            document.getElementById('gw-amplitude').addEventListener('input', e => { config.gravwave.amplitude = parseFloat(e.target.value); document.getElementById('gw-amplitude-value').textContent = parseFloat(e.target.value).toFixed(2); });
            document.getElementById('gw-wavelength').addEventListener('input', e => { config.gravwave.wavelength = parseFloat(e.target.value); document.getElementById('gw-wavelength-value').textContent = e.target.value; });
            document.getElementById('fractal-reset').addEventListener('click', () => initFractal(true));
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
        }

        // --- Logique Plein Écran ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                mainContainer.requestFullscreen().catch(err => {
                    alert(`Erreur lors du passage en plein écran: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function updateFullscreenIcon() {
            const isFullscreen = !!document.fullscreenElement;
            iconEnterFs.classList.toggle('hidden', isFullscreen);
            iconExitFs.classList.toggle('hidden', !isFullscreen);
        }

        // --- Logique de Changement d'Effet ---
        function switchEffect(effectName) {
            cancelAnimationFrame(animationFrameId);
            cleanupCurrentEffect();
            currentEffect = effectName;
            
            canvas = document.createElement('canvas');
            canvasContainer.insertBefore(canvas, fullscreenBtn);

            effectButtons.forEach(btn => btn.classList.toggle('active', btn.id === `btn-${effectName}`));
            allControls.forEach(control => control.classList.toggle('hidden', !control.dataset.effect.includes(effectName)));
            
            initNewEffect();
            mainLoop(0);
        }

        function cleanupCurrentEffect() {
            if (canvas) {
                canvas.remove();
            }
            if (three && three.renderer) {
                three.controls.dispose();
                three.renderer.dispose();
                three = null;
            }
            if (fractal && fractal.worker) {
                fractal.worker.terminate();
                fractal = null;
            }
        }

        function initNewEffect() {
            canvas.style.cursor = (currentEffect === 'gravwave') ? 'grab' : 'pointer';
            
            if (currentEffect !== 'gravwave') {
                ctx = canvas.getContext('2d');
            }

            switch (currentEffect) {
                case 'tunnel': initTunnel(); break;
                case 'gravwave': initGravWave(); break;
                case 'fractal': initFractal(true); break;
            }
            onResize();
        }

        // --- Fonctions d'Initialisation Spécifiques ---
        function initTunnel() {
            tunnelParticles = Array.from({ length: config.tunnel.density }, () => ({
                angle: Math.random() * Math.PI * 2,
                radius: Math.random() * canvas.width / 4,
                color: `hsl(${Math.random() * 360}, 100%, 70%)`
            }));
        }

        function initGravWave() {
            const { gridSize, gridSpacing } = config.gravwave;
            three = {};
            three.scene = new THREE.Scene();
            three.camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 2000);
            three.camera.position.set(gridSize * 1.2, gridSize * 1.2, gridSize * 1.2);
            three.renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            three.renderer.setSize(canvas.width, canvas.height);
            three.renderer.setPixelRatio(window.devicePixelRatio);
            three.controls = new OrbitControls(three.camera, three.renderer.domElement);
            three.controls.enableDamping = true;
            
            const numParticles = gridSize * gridSize;
            const positions = new Float32Array(numParticles * 3);
            three.originalPositions = new Float32Array(numParticles * 3);
            const halfGridWorldSize = (gridSize * gridSpacing) / 2;
            for (let x = 0, i = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    const posX = x * gridSpacing - halfGridWorldSize;
                    const posZ = z * gridSpacing - halfGridWorldSize;
                    positions[i * 3] = posX;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = posZ;
                    three.originalPositions[i*3] = posX;
                    three.originalPositions[i*3+1] = 0;
                    three.originalPositions[i*3+2] = posZ;
                    i++;
                }
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0x9e8cff, size: 2.5, blending: THREE.AdditiveBlending });
            three.particles = new THREE.Points(geometry, material);
            three.scene.add(three.particles);
        }

        function initFractal(resetView) {
            if (resetView) {
                config.fractal.centerX = -0.5;
                config.fractal.centerY = 0;
                config.fractal.scale = 2;
                config.fractal.maxIterations = 100;
            }
            if (!fractal) {
                const workerBlob = new Blob([document.getElementById('fractal-worker').textContent], { type: 'application/javascript' });
                fractal = { worker: new Worker(URL.createObjectURL(workerBlob)) };
                fractal.worker.onmessage = e => { if(ctx) ctx.putImageData(e.data, 0, 0); };
            }
            canvas.addEventListener('click', handleFractalClick);
            fractal.worker.postMessage({ ...config.fractal, width: canvas.width, height: canvas.height });
        }
        
        // --- Gestionnaires d'Événements ---
        function handleFractalClick(e) {
            if (currentEffect !== 'fractal') return;
            canvas.removeEventListener('click', handleFractalClick);
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            config.fractal.centerX += (x / canvas.width - 0.5) * 2 * config.fractal.scale;
            config.fractal.centerY += (y / canvas.height - 0.5) * 2 * config.fractal.scale;
            config.fractal.scale *= 0.5;
            config.fractal.maxIterations = Math.min(1000, Math.floor(config.fractal.maxIterations * 1.5));
            initFractal(false);
        }

        // --- Fonctions de Dessin ---
        function drawSpiral(w, h, cx, cy) { ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,w,h); ctx.lineWidth = config.spiral.thickness; const maxR = Math.sqrt(cx*cx+cy*cy); for (let i=0; i<config.spiral.arms; i++) { ctx.beginPath(); const angleOffset = (Math.PI*2/config.spiral.arms)*i; for (let r=0; r<maxR; r+=2) { const angle = r*0.1 + time*config.spiral.rotationSpeed + angleOffset; const x = cx+Math.cos(angle)*r; const y = cy+Math.sin(angle)*r; if(r===0)ctx.moveTo(x,y); else ctx.lineTo(x,y); } const hue = (time*config.spiral.colorSpeed + i*(360/config.spiral.arms))%360; ctx.strokeStyle = `hsl(${hue},100%,60%)`; ctx.stroke(); } }
        function drawTunnel(w, h, cx, cy) { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0,0,w,h); const maxR = w/2; tunnelParticles.forEach(p => { p.radius += config.tunnel.speed; if (p.radius > maxR) p.radius = Math.random()*10; const x = cx+Math.cos(p.angle)*p.radius; const y = cy+Math.sin(p.angle)*p.radius; const size = p.radius/50; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fillStyle=p.color; ctx.fill(); }); }
        function drawKaleidoscope(w, h, cx, cy) { ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fillRect(0,0,w,h); const { slices, speed } = config.kaleidoscope; const sliceAngle = Math.PI*2/slices; for (let i=0; i<slices; i++) { ctx.save(); ctx.translate(cx,cy); ctx.rotate(i*sliceAngle); if(i%2===0)ctx.scale(1,-1); for (let j=0; j<10; j++) { const hue = (time*50+j*20)%360; ctx.fillStyle = `hsl(${hue},100%,50%)`; const x = Math.cos(time*speed+j)*(w/4); const y = Math.sin(time*speed*2+j)*(h/4); const size = 5+Math.sin(time+j)*4; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill(); } ctx.restore(); } }
        function drawGravWave() {
            if (!three) return;
            const { amplitude, wavelength } = config.gravwave;
            const waveNumber = (2*Math.PI)/wavelength;
            const angularFrequency = (2*Math.PI)/30;
            const positions = three.particles.geometry.attributes.position.array;
            for (let i=0; i<positions.length/3; i++) {
                const x0 = three.originalPositions[i*3];
                const y0 = three.originalPositions[i*3+1];
                const z0 = three.originalPositions[i*3+2];
                const waveEffect = amplitude * Math.sin(waveNumber * z0 - angularFrequency * time);
                positions[i*3] = x0 * (1 + waveEffect);
                positions[i*3+1] = y0 - (x0 * waveEffect);
            }
            three.particles.geometry.attributes.position.needsUpdate = true;
            three.controls.update();
            three.renderer.render(three.scene, three.camera);
        }

        // --- Boucle Principale et Initialisation ---
        function mainLoop(timestamp) {
            time = timestamp / 1000;
            const w = canvas.width, h = canvas.height, cx = w/2, cy = h/2;

            switch (currentEffect) {
                case 'spiral': drawSpiral(w,h,cx,cy); break;
                case 'tunnel': drawTunnel(w,h,cx,cy); break;
                case 'kaleidoscope': drawKaleidoscope(w,h,cx,cy); break;
                case 'gravwave': drawGravWave(); break;
            }
            animationFrameId = requestAnimationFrame(mainLoop);
        }

        function onResize() {
            const w = canvasContainer.clientWidth;
            const h = canvasContainer.clientHeight;
            if (canvas) {
                canvas.width = w;
                canvas.height = h;
            }
            if (three && three.camera) {
                three.camera.aspect = w / h;
                three.camera.updateProjectionMatrix();
                three.renderer.setSize(w, h);
            }
            if (currentEffect === 'tunnel') initTunnel();
            if (currentEffect === 'fractal') initFractal(false);
        }

        window.addEventListener('resize', onResize);
        setupEventListeners();
        switchEffect('spiral');

    </script>
</body>
</html>
